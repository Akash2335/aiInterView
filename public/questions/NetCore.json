{
  "data": [
    {
      "id": 1,
      "question": "What is the difference between .NET Framework and .NET Core?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": ".NET Framework: Windows-only, system-wide installation, mature ecosystem. .NET Core: Cross-platform, self-contained deployments, modular, faster, cloud-optimized, open-source. .NET 5+ unified them into single .NET platform with best features from both."
    },
    {
      "id": 2,
      "question": "Explain middleware in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Middleware are components that handle requests and responses in pipeline. Executed in sequence. Built-in middleware: Authentication, Routing, Static Files, CORS. Custom middleware via Use, Run, Map. Configure in Startup.Configure or Program.cs. Order is critical for proper request processing."
    },
    {
      "id": 3,
      "question": "How does dependency injection work in .NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Built-in DI container in ASP.NET Core. Service lifetimes: Transient (new instance every request), Scoped (once per request), Singleton (single instance for application lifetime). Register services in Startup.ConfigureServices or with HostBuilder. Promotes loose coupling and testability."
    },
    {
      "id": 4,
      "question": "What is Kestrel web server?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Kestrel is cross-platform, high-performance web server for ASP.NET Core. Default web server, can run standalone or behind reverse proxy (IIS, Nginx, Apache). Handles HTTP requests directly, supports HTTPS, WebSockets, and various protocols. Optimized for performance and scalability."
    },
    {
      "id": 5,
      "question": "Explain configuration in .NET Core (appsettings.json).",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Configuration system with multiple providers (JSON, environment variables, command line, Azure Key Vault). Hierarchical structure, environment-specific files (appsettings.Development.json). Access via IConfiguration interface, options pattern for strongly-typed access. Supports reload on change."
    },
    {
      "id": 6,
      "question": "How do you implement authentication and authorization?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Authentication: JWT Bearer, Cookie, OAuth2, OpenID Connect. Authorization: Policies, Roles, Claims. Use [Authorize] attribute, configure with services.AddAuthentication().AddJwtBearer(). Implement custom requirements with IAuthorizationRequirement and AuthorizationHandler<T>."
    },
    {
      "id": 7,
      "question": "What are action filters in ASP.NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Action filters run code before/after action execution. Types: Authorization, Resource, Action, Exception, Result. Implement IActionFilter or override ActionFilterAttribute. Use for: logging, validation, caching, exception handling. Can be global, per-controller, or per-action."
    },
    {
      "id": 8,
      "question": "Explain logging and monitoring in .NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Built-in logging with ILogger<T>, multiple providers (Console, Debug, EventSource, Application Insights). Log levels: Trace, Debug, Information, Warning, Error, Critical. Use structured logging with message templates. Integrate with monitoring systems like Application Insights, Prometheus."
    },
    {
      "id": 9,
      "question": "How do you handle errors and exceptions?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use try-catch blocks, exception filters, exception handling middleware, custom exception handlers. Developer Exception Page for development, UseExceptionHandler for production. Implement Problem Details for API errors (RFC 7807). Use health checks for monitoring."
    },
    {
      "id": 10,
      "question": "What is the Startup class and Program.cs in .NET 6+?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Startup class (traditional): ConfigureServices for DI, Configure for middleware. .NET 6+: Minimal hosting model with top-level statements in Program.cs. Services and middleware configured directly in Program.cs. Simplified startup with WebApplicationBuilder and WebApplication."
    },
    {
      "id": 11,
      "question": "Explain dependency injection lifetimes in .NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Transient: New instance every time requested. Scoped: Single instance per request. Singleton: Single instance for application lifetime. Choose based on: state management, thread safety, resource usage. Be careful with captive dependencies and disposing."
    },
    {
      "id": 12,
      "question": "What are hosted services in ASP.NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Hosted services run background tasks in ASP.NET Core applications. Implement IHostedService or inherit from BackgroundService. Used for: periodic tasks, message processing, cache warming. Lifetime managed by dependency injection. Start/stop with application."
    },
    {
      "id": 13,
      "question": "How do you implement health checks?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use services.AddHealthChecks().AddCheck<MyHealthCheck>(). Map endpoints with MapHealthChecks. Custom health checks implement IHealthCheck. Used by: load balancers, container orchestrators, monitoring systems. Supports tags, filtering, and custom responses."
    },
    {
      "id": 14,
      "question": "What is the options pattern in .NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Options pattern provides strongly-typed access to configuration. Use IOptions<T>, IOptionsSnapshot<T>, IOptionsMonitor<T>. Configure: services.Configure<MyOptions>(Configuration.GetSection(\"MySection\")). Supports named options, validation, and reload-on-change."
    },
    {
      "id": 15,
      "question": "Explain the difference between IOptions, IOptionsSnapshot, and IOptionsMonitor.",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "IOptions: Singleton, doesn't detect configuration changes. IOptionsSnapshot: Scoped, detects changes per request. IOptionsMonitor: Singleton, detects changes, can be used to get current options anytime. Choose based on need for configuration updates."
    },
    {
      "id": 16,
      "question": "How do you implement caching in .NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "In-memory caching: services.AddMemoryCache(), IDistributedCache for distributed caching (Redis, SQL Server). Response caching: [ResponseCache] attribute. Use IMemoryCache or IDistributedCache interfaces. Configure expiration, size limits, and cache policies."
    },
    {
      "id": 17,
      "question": "What are tag helpers in ASP.NET Core MVC?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Tag helpers transform HTML elements on server. Built-in: Form, Input, Label, Validation, Select. Custom tag helpers inherit from TagHelper. Provide HTML-friendly development experience with IntelliSense. Server-side processing with HTML-like syntax."
    },
    {
      "id": 18,
      "question": "Explain view components in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "View components render reusable chunks of UI with logic. Like partial views but with business logic. InvokeAsync returns IViewComponentResult. More powerful than partial views. Used for: dynamic navigation, shopping carts, sidebar content, widgets."
    },
    {
      "id": 19,
      "question": "How do you implement API versioning?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Use Microsoft.AspNetCore.Mvc.Versioning package. Strategies: URL path, query string, headers, media type. Configure: services.AddApiVersioning(). Use [ApiVersion] attribute. Supports version negotiation, sunsetting, and version-neutral APIs."
    },
    {
      "id": 20,
      "question": "What is the difference between ActionResult and IActionResult?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IActionResult is interface representing action result. ActionResult<T> is return type that can be specific type or action result. Provides compile-time and runtime type safety for API responses. Better for OpenAPI/Swagger documentation."
    },
    {
      "id": 21,
      "question": "Explain model binding and validation in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Model binding maps request data to action parameters. Sources: [FromQuery], [FromRoute], [FromBody], [FromForm]. Validation with DataAnnotations [Required], [StringLength], custom validators. Automatic 400 responses with validation errors. Customize with ModelState."
    },
    {
      "id": 22,
      "question": "What are filters in ASP.NET Core and their types?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Authorization filters: Run first, handle authentication/authorization. Resource filters: Run after authorization, handle caching. Action filters: Before/after action execution. Exception filters: Handle exceptions. Result filters: Before/after action result execution. Can be global, per-controller, or per-action."
    },
    {
      "id": 23,
      "question": "How do you implement response caching?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use [ResponseCache] attribute with Duration, Location, VaryBy* properties. Use ResponseCachingMiddleware. Client-side caching with cache-control headers. Server-side caching with memory/distributed cache. Configure cache profiles for reusability."
    },
    {
      "id": 24,
      "question": "What is minimal APIs in .NET 6+?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Minimal APIs provide simplified syntax for HTTP APIs. app.MapGet(\"/hello\", () => \"Hello World\"); Reduces boilerplate for simple APIs. Includes parameter binding, response formatting, and OpenAPI support. Ideal for microservices and simple endpoints."
    },
    {
      "id": 25,
      "question": "Explain endpoint routing in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Endpoint routing separates route matching and endpoint execution. MapGet, MapPost, MapControllers. Provides better performance and flexibility. Endpoint metadata enables features like CORS, authorization per endpoint. Replaces IRouter-based routing."
    },
    {
      "id": 26,
      "question": "How do you implement CORS in ASP.NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "services.AddCors() with policy configuration. Use [EnableCors] attribute or endpoint routing. Configure origins, methods, headers, credentials. Apply globally or per endpoint. Important for web apps calling APIs from different domains."
    },
    {
      "id": 27,
      "question": "What are the different hosting models?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "In-process: IIS with ASP.NET Core Module, better performance. Out-of-process: Kestrel behind reverse proxy. Generic Host: For non-web apps (workers, services). WebApplication host: .NET 6+ minimal hosting model. Choose based on deployment environment."
    },
    {
      "id": 28,
      "question": "Explain the appsettings.json configuration hierarchy.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "appsettings.json (base) → appsettings.{Environment}.json (environment-specific) → environment variables → command line args → user secrets (development). Later sources override earlier ones. Use ConfigurationBuilder to customize hierarchy."
    },
    {
      "id": 29,
      "question": "How do you use environment variables in .NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Environment variables override appsettings.json. Use __ as hierarchy separator (ConnectionStrings__DefaultConnection). Access via IConfiguration or Environment.GetEnvironmentVariable(). Use for: connection strings, API keys, feature flags."
    },
    {
      "id": 30,
      "question": "What is the difference between AddMvc and AddControllers?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "AddMvc: Adds full MVC stack (views, Razor Pages, API controllers). AddControllers: Adds only API controllers (no views). AddControllersWithViews: API controllers + views. Use AddControllers for Web APIs, AddMvc/AddControllersWithViews for MVC apps with views."
    },
    {
      "id": 31,
      "question": "Explain Razor Pages in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Razor Pages are page-based programming model. Each page has .cshtml file and PageModel class. Simpler than MVC for page-focused scenarios. Use @page directive, handler methods (OnGet, OnPost). Built-in anti-forgery protection. Good for traditional web apps."
    },
    {
      "id": 32,
      "question": "How do you implement background tasks with BackgroundService?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Inherit from BackgroundService, override ExecuteAsync. Use cancellation token for graceful shutdown. Register as hosted service: services.AddHostedService<MyBackgroundService>. Handle exceptions and implement retry logic. Use for: queue processing, periodic tasks."
    },
    {
      "id": 33,
      "question": "What is the difference between IHttpClientFactory and HttpClient?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "HttpClient can cause socket exhaustion if not reused properly. IHttpClientFactory manages HttpClient lifetime, provides named/typed clients, handles resilience, integrates with DI. Better performance, DNS updates, logging, and Polly integration."
    },
    {
      "id": 34,
      "question": "Explain the built-in DI container vs third-party containers.",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Built-in: Simple, fast, supports most common scenarios. Third-party (Autofac, Simple Injector): Advanced features (property injection, convention-based registration, child containers). Built-in sufficient for most applications. Choose third-party for complex needs."
    },
    {
      "id": 35,
      "question": "How do you implement feature flags?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use Microsoft.FeatureManagement package. Configure in appsettings.json, use [FeatureGate] attribute or IFeatureManager service. Supports filters (percentage, time window, targeting). Enable gradual rollouts, A/B testing, emergency kill switches."
    },
    {
      "id": 36,
      "question": "What are the different ways to configure services?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "In Startup.ConfigureServices (traditional), in Program.cs (.NET 6+), using HostBuilder, using configuration files, convention-based with Scrutor. Use extension methods for clean organization (services.AddMyService())."
    },
    {
      "id": 37,
      "question": "Explain the request pipeline in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Request → Middleware (Authentication, Routing, etc.) → Endpoint Middleware → Controller/Action → Result → Middleware (in reverse) → Response. Each middleware can short-circuit pipeline. Order determines execution sequence. Customize with Use, Run, Map."
    },
    {
      "id": 38,
      "question": "How do you implement custom middleware?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Class-based: Implement IMiddleware or convention-based class with InvokeAsync method. Inline: app.Use(async (context, next) => { await next(); }). Use IApplicationBuilder.UseMiddleware<T>(). Handle exceptions, modify request/response, add headers."
    },
    {
      "id": 39,
      "question": "What is the difference between transient, scoped, and singleton in practice?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Transient: Stateless services, lightweight. Scoped: DbContext, unit of work pattern. Singleton: Configuration, logging, cached data. Avoid captive dependencies (singleton depending on scoped). Use factory pattern when needed."
    },
    {
      "id": 40,
      "question": "How do you implement API documentation with Swagger/OpenAPI?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use Swashbuckle.AspNetCore package. services.AddSwaggerGen(), app.UseSwagger(). Use [OpenApi] attributes, XML comments. Configure security definitions, operation filters. Provides interactive API documentation and client generation."
    }
  ]
}