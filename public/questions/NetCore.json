{
  "data": [
    {
      "id": 1,
      "question": "What is the difference between .NET Framework and .NET Core?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": ".NET Framework: Windows-only, system-wide installation, mature ecosystem. .NET Core: Cross-platform, self-contained deployments, modular, faster, cloud-optimized, open-source. .NET 5+ unified them into single .NET platform with best features from both."
    },
    {
      "id": 2,
      "question": "Explain middleware in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Middleware are components that handle requests and responses in pipeline. Executed in sequence. Built-in middleware: Authentication, Routing, Static Files, CORS. Custom middleware via Use, Run, Map. Configure in Startup.Configure or Program.cs. Order is critical for proper request processing."
    },
    {
      "id": 3,
      "question": "How does dependency injection work in .NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Built-in DI container in ASP.NET Core. Service lifetimes: Transient (new instance every request), Scoped (once per request), Singleton (single instance for application lifetime). Register services in Startup.ConfigureServices or with HostBuilder. Promotes loose coupling and testability."
    },
    {
      "id": 4,
      "question": "What is Kestrel web server?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Kestrel is cross-platform, high-performance web server for ASP.NET Core. Default web server, can run standalone or behind reverse proxy (IIS, Nginx, Apache). Handles HTTP requests directly, supports HTTPS, WebSockets, and various protocols. Optimized for performance and scalability."
    },
    {
      "id": 5,
      "question": "Explain configuration in .NET Core (appsettings.json).",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Configuration system with multiple providers (JSON, environment variables, command line, Azure Key Vault). Hierarchical structure, environment-specific files (appsettings.Development.json). Access via IConfiguration interface, options pattern for strongly-typed access. Supports reload on change."
    },
    {
      "id": 6,
      "question": "How do you implement authentication and authorization?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Authentication: JWT Bearer, Cookie, OAuth2, OpenID Connect. Authorization: Policies, Roles, Claims. Use [Authorize] attribute, configure with services.AddAuthentication().AddJwtBearer(). Implement custom requirements with IAuthorizationRequirement and AuthorizationHandler<T>."
    },
    {
      "id": 7,
      "question": "What are action filters in ASP.NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Action filters run code before/after action execution. Types: Authorization, Resource, Action, Exception, Result. Implement IActionFilter or override ActionFilterAttribute. Use for: logging, validation, caching, exception handling. Can be global, per-controller, or per-action."
    },
    {
      "id": 8,
      "question": "Explain logging and monitoring in .NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Built-in logging with ILogger<T>, multiple providers (Console, Debug, EventSource, Application Insights). Log levels: Trace, Debug, Information, Warning, Error, Critical. Use structured logging with message templates. Integrate with monitoring systems like Application Insights, Prometheus."
    },
    {
      "id": 9,
      "question": "How do you handle errors and exceptions?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use try-catch blocks, exception filters, exception handling middleware, custom exception handlers. Developer Exception Page for development, UseExceptionHandler for production. Implement Problem Details for API errors (RFC 7807). Use health checks for monitoring."
    },
    {
      "id": 10,
      "question": "What is the Startup class and Program.cs in .NET 6+?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Startup class (traditional): ConfigureServices for DI, Configure for middleware. .NET 6+: Minimal hosting model with top-level statements in Program.cs. Services and middleware configured directly in Program.cs. Simplified startup with WebApplicationBuilder and WebApplication."
    },
    {
      "id": 11,
      "question": "Explain dependency injection lifetimes in .NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Transient: New instance every time requested. Scoped: Single instance per request. Singleton: Single instance for application lifetime. Choose based on: state management, thread safety, resource usage. Be careful with captive dependencies and disposing."
    },
    {
      "id": 12,
      "question": "What are hosted services in ASP.NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Hosted services run background tasks in ASP.NET Core applications. Implement IHostedService or inherit from BackgroundService. Used for: periodic tasks, message processing, cache warming. Lifetime managed by dependency injection. Start/stop with application."
    },
    {
      "id": 13,
      "question": "How do you implement health checks?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use services.AddHealthChecks().AddCheck<MyHealthCheck>(). Map endpoints with MapHealthChecks. Custom health checks implement IHealthCheck. Used by: load balancers, container orchestrators, monitoring systems. Supports tags, filtering, and custom responses."
    },
    {
      "id": 14,
      "question": "What is the options pattern in .NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Options pattern provides strongly-typed access to configuration. Use IOptions<T>, IOptionsSnapshot<T>, IOptionsMonitor<T>. Configure: services.Configure<MyOptions>(Configuration.GetSection(\"MySection\")). Supports named options, validation, and reload-on-change."
    },
    {
      "id": 15,
      "question": "Explain the difference between IOptions, IOptionsSnapshot, and IOptionsMonitor.",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "IOptions: Singleton, doesn't detect configuration changes. IOptionsSnapshot: Scoped, detects changes per request. IOptionsMonitor: Singleton, detects changes, can be used to get current options anytime. Choose based on need for configuration updates."
    },
    {
      "id": 16,
      "question": "How do you implement caching in .NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "In-memory caching: services.AddMemoryCache(), IDistributedCache for distributed caching (Redis, SQL Server). Response caching: [ResponseCache] attribute. Use IMemoryCache or IDistributedCache interfaces. Configure expiration, size limits, and cache policies."
    },
    {
      "id": 17,
      "question": "What are tag helpers in ASP.NET Core MVC?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Tag helpers transform HTML elements on server. Built-in: Form, Input, Label, Validation, Select. Custom tag helpers inherit from TagHelper. Provide HTML-friendly development experience with IntelliSense. Server-side processing with HTML-like syntax."
    },
    {
      "id": 18,
      "question": "Explain view components in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "View components render reusable chunks of UI with logic. Like partial views but with business logic. InvokeAsync returns IViewComponentResult. More powerful than partial views. Used for: dynamic navigation, shopping carts, sidebar content, widgets."
    },
    {
      "id": 19,
      "question": "How do you implement API versioning?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Use Microsoft.AspNetCore.Mvc.Versioning package. Strategies: URL path, query string, headers, media type. Configure: services.AddApiVersioning(). Use [ApiVersion] attribute. Supports version negotiation, sunsetting, and version-neutral APIs."
    },
    {
      "id": 20,
      "question": "What is the difference between ActionResult and IActionResult?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IActionResult is interface representing action result. ActionResult<T> is return type that can be specific type or action result. Provides compile-time and runtime type safety for API responses. Better for OpenAPI/Swagger documentation."
    },
    {
      "id": 21,
      "question": "Explain model binding and validation in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Model binding maps request data to action parameters. Sources: [FromQuery], [FromRoute], [FromBody], [FromForm]. Validation with DataAnnotations [Required], [StringLength], custom validators. Automatic 400 responses with validation errors. Customize with ModelState."
    },
    {
      "id": 22,
      "question": "What are filters in ASP.NET Core and their types?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Authorization filters: Run first, handle authentication/authorization. Resource filters: Run after authorization, handle caching. Action filters: Before/after action execution. Exception filters: Handle exceptions. Result filters: Before/after action result execution. Can be global, per-controller, or per-action."
    },
    {
      "id": 23,
      "question": "How do you implement response caching?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use [ResponseCache] attribute with Duration, Location, VaryBy* properties. Use ResponseCachingMiddleware. Client-side caching with cache-control headers. Server-side caching with memory/distributed cache. Configure cache profiles for reusability."
    },
    {
      "id": 24,
      "question": "What is minimal APIs in .NET 6+?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Minimal APIs provide simplified syntax for HTTP APIs. app.MapGet(\"/hello\", () => \"Hello World\"); Reduces boilerplate for simple APIs. Includes parameter binding, response formatting, and OpenAPI support. Ideal for microservices and simple endpoints."
    },
    {
      "id": 25,
      "question": "Explain endpoint routing in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Endpoint routing separates route matching and endpoint execution. MapGet, MapPost, MapControllers. Provides better performance and flexibility. Endpoint metadata enables features like CORS, authorization per endpoint. Replaces IRouter-based routing."
    },
    {
      "id": 26,
      "question": "How do you implement CORS in ASP.NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "services.AddCors() with policy configuration. Use [EnableCors] attribute or endpoint routing. Configure origins, methods, headers, credentials. Apply globally or per endpoint. Important for web apps calling APIs from different domains."
    },
    {
      "id": 27,
      "question": "What are the different hosting models?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "In-process: IIS with ASP.NET Core Module, better performance. Out-of-process: Kestrel behind reverse proxy. Generic Host: For non-web apps (workers, services). WebApplication host: .NET 6+ minimal hosting model. Choose based on deployment environment."
    },
    {
      "id": 28,
      "question": "Explain the appsettings.json configuration hierarchy.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "appsettings.json (base) → appsettings.{Environment}.json (environment-specific) → environment variables → command line args → user secrets (development). Later sources override earlier ones. Use ConfigurationBuilder to customize hierarchy."
    },
    {
      "id": 29,
      "question": "How do you use environment variables in .NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Environment variables override appsettings.json. Use __ as hierarchy separator (ConnectionStrings__DefaultConnection). Access via IConfiguration or Environment.GetEnvironmentVariable(). Use for: connection strings, API keys, feature flags."
    },
    {
      "id": 30,
      "question": "What is the difference between AddMvc and AddControllers?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "AddMvc: Adds full MVC stack (views, Razor Pages, API controllers). AddControllers: Adds only API controllers (no views). AddControllersWithViews: API controllers + views. Use AddControllers for Web APIs, AddMvc/AddControllersWithViews for MVC apps with views."
    },
    {
      "id": 31,
      "question": "Explain Razor Pages in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Razor Pages are page-based programming model. Each page has .cshtml file and PageModel class. Simpler than MVC for page-focused scenarios. Use @page directive, handler methods (OnGet, OnPost). Built-in anti-forgery protection. Good for traditional web apps."
    },
    {
      "id": 32,
      "question": "How do you implement background tasks with BackgroundService?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Inherit from BackgroundService, override ExecuteAsync. Use cancellation token for graceful shutdown. Register as hosted service: services.AddHostedService<MyBackgroundService>. Handle exceptions and implement retry logic. Use for: queue processing, periodic tasks."
    },
    {
      "id": 33,
      "question": "What is the difference between IHttpClientFactory and HttpClient?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "HttpClient can cause socket exhaustion if not reused properly. IHttpClientFactory manages HttpClient lifetime, provides named/typed clients, handles resilience, integrates with DI. Better performance, DNS updates, logging, and Polly integration."
    },
    {
      "id": 34,
      "question": "Explain the built-in DI container vs third-party containers.",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Built-in: Simple, fast, supports most common scenarios. Third-party (Autofac, Simple Injector): Advanced features (property injection, convention-based registration, child containers). Built-in sufficient for most applications. Choose third-party for complex needs."
    },
    {
      "id": 35,
      "question": "How do you implement feature flags?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use Microsoft.FeatureManagement package. Configure in appsettings.json, use [FeatureGate] attribute or IFeatureManager service. Supports filters (percentage, time window, targeting). Enable gradual rollouts, A/B testing, emergency kill switches."
    },
    {
      "id": 36,
      "question": "What are the different ways to configure services?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "In Startup.ConfigureServices (traditional), in Program.cs (.NET 6+), using HostBuilder, using configuration files, convention-based with Scrutor. Use extension methods for clean organization (services.AddMyService())."
    },
    {
      "id": 37,
      "question": "Explain the request pipeline in ASP.NET Core.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Request → Middleware (Authentication, Routing, etc.) → Endpoint Middleware → Controller/Action → Result → Middleware (in reverse) → Response. Each middleware can short-circuit pipeline. Order determines execution sequence. Customize with Use, Run, Map."
    },
    {
      "id": 38,
      "question": "How do you implement custom middleware?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Class-based: Implement IMiddleware or convention-based class with InvokeAsync method. Inline: app.Use(async (context, next) => { await next(); }). Use IApplicationBuilder.UseMiddleware<T>(). Handle exceptions, modify request/response, add headers."
    },
    {
      "id": 39,
      "question": "What is the difference between transient, scoped, and singleton in practice?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Transient: Stateless services, lightweight. Scoped: DbContext, unit of work pattern. Singleton: Configuration, logging, cached data. Avoid captive dependencies (singleton depending on scoped). Use factory pattern when needed."
    },
    {
      "id": 40,
      "question": "How do you implement API documentation with Swagger/OpenAPI?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use Swashbuckle.AspNetCore package. services.AddSwaggerGen(), app.UseSwagger(). Use [OpenApi] attributes, XML comments. Configure security definitions, operation filters. Provides interactive API documentation and client generation."
    },
    {
      "id": 41,
      "question": "Explain the difference between AddDbContext and AddDbContextFactory.",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "AddDbContext: Registers DbContext with scoped lifetime. AddDbContextFactory: Registers factory to create DbContext instances, useful for background services or when you need multiple instances per scope. Choose based on usage patterns."
    },
    {
      "id": 42,
      "question": "What is the purpose of Program.cs in .NET 6+?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Program.cs replaces Startup class with minimal hosting model. Top-level statements, WebApplicationBuilder for configuration, WebApplication for middleware. Simplified startup, reduced boilerplate. Supports all traditional features in cleaner syntax."
    },
    {
      "id": 43,
      "question": "How do you handle file uploads in ASP.NET Core?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use IFormFile in action parameters, [FromForm] binding. Validate file size, type, name. Use streaming for large files. Store securely (not in wwwroot). Implement virus scanning. Use multipart/form-data content type."
    },
    {
      "id": 44,
      "question": "Explain the difference between app.Run and app.Use.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "app.Use: Adds middleware to pipeline, can call next middleware. app.Run: Terminal middleware, ends pipeline. app.Map: Branches pipeline based on condition. Use Run for final response, Use for middleware that might continue pipeline."
    },
    {
      "id": 45,
      "question": "What are the different authentication schemes?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Cookie authentication: Traditional web apps. JWT Bearer: APIs, SPA. OAuth2/OpenID Connect: Social logins, enterprise. Windows authentication: Intranet. Certificate authentication: Machine-to-machine. Configure multiple schemes with authentication hander."
    },
    {
      "id": 46,
      "question": "How do you implement rate limiting?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Use AspNetCore.RateLimiting package (.NET 7+). Configure policies: Fixed window, sliding window, token bucket, concurrent. Apply with [EnableRateLimiting], [DisableRateLimiting]. Customize based on IP, user, client, endpoint."
    },
    {
      "id": 47,
      "question": "Explain the difference between ILogger and ILogger<T>.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "ILogger: Non-generic interface. ILogger<T>: Generic interface with category name (usually type T). ILogger<T> is preferred as it provides better filtering and organization. Category appears in logs for filtering."
    },
    {
      "id": 48,
      "question": "What is the purpose of the WebApplicationBuilder?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "WebApplicationBuilder (.NET 6+) simplifies application configuration. Properties: Configuration, Environment, Logging, Services, Host, WebHost. Build() creates WebApplication. Replaces Host.CreateDefaultBuilder and Startup class in most scenarios."
    },
    {
      "id": 49,
      "question": "How do you implement custom configuration providers?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IConfigurationSource and IConfigurationProvider. Add with ConfigurationBuilder.Add(). Use for: database configuration, remote config services, encrypted config. Support reloading and change notifications."
    },
    {
      "id": 50,
      "question": "Explain the difference between AddRouting and UseRouting.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "AddRouting: Registers routing services in DI container. UseRouting: Adds routing middleware to pipeline. Both are needed for endpoint routing. AddRouting in ConfigureServices, UseRouting in Configure (or Program.cs in .NET 6+)."
    },
    {
      "id": 51,
      "question": "What are the different ways to return responses from controllers?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Ok(), BadRequest(), NotFound() for HTTP status codes. View() for Razor views. Json() for JSON data. File() for file downloads. Redirect() for redirects. Content() for custom content. IActionResult for flexibility, specific types for simplicity."
    },
    {
      "id": 52,
      "question": "How do you implement custom model binders?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IModelBinder, register with [ModelBinder] attribute or Provider. Use for complex binding scenarios not covered by default. Can bind from multiple sources, handle custom formats, implement validation."
    },
    {
      "id": 53,
      "question": "Explain the purpose of the IWebHostEnvironment interface.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IWebHostEnvironment provides information about web hosting environment. Properties: EnvironmentName, WebRootPath, ContentRootPath, ApplicationName. Use for environment-specific behavior, path resolution, configuration."
    },
    {
      "id": 54,
      "question": "What is the difference between services.Configure and services.PostConfigure?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "services.Configure: Binds configuration section to options. services.PostConfigure: Runs after configuration binding, allows modification of options. Use PostConfigure for: setting defaults, validation, transformation of configured values."
    },
    {
      "id": 55,
      "question": "How do you implement request localization?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use RequestLocalizationMiddleware. Configure supported cultures, default culture. Use [FromHeader], cookies, or query string for culture selection. Use IStringLocalizer for resource files. Support right-to-left languages when needed."
    },
    {
      "id": 56,
      "question": "Explain the difference between IMemoryCache and IDistributedCache.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IMemoryCache: In-memory cache, fast, single server. IDistributedCache: Distributed cache (Redis, SQL Server), shared across servers. Use IMemoryCache for single-server scenarios, IDistributedCache for web farms, cloud deployments."
    },
    {
      "id": 57,
      "question": "What are the different hosting environments?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "Development: Local development. Staging: Pre-production testing. Production: Live environment. Custom: Additional environments. Set via ASPNETCORE_ENVIRONMENT variable. Affects: configuration, error handling, logging, feature flags."
    },
    {
      "id": 58,
      "question": "How do you implement custom validation attributes?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Inherit from ValidationAttribute, override IsValid. Use for complex validation logic. Can be client-side (implement IClientModelValidator) and server-side. Register with services.AddMvc().AddDataAnnotationsLocalization()."
    },
    {
      "id": 59,
      "question": "Explain the purpose of the ConfigurationManager in .NET 6+.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "ConfigurationManager (.NET 6+) combines IConfiguration and IConfigurationBuilder. Single object for reading and building configuration. Used by WebApplicationBuilder. Simplifies configuration management in minimal APIs."
    },
    {
      "id": 60,
      "question": "What is the difference between MapGet and MapMethods?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "MapGet: Maps HTTP GET requests. MapMethods: Maps specific HTTP methods (GET, POST, PUT, etc.). MapGet is convenience method for GET, MapMethods is flexible for any HTTP method or multiple methods."
    },
    {
      "id": 61,
      "question": "How do you implement health checks for dependencies?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use AddCheck for custom dependencies, AddDbContextCheck for EF Core, AddUrlGroup for HTTP endpoints. Implement IHealthCheck for complex checks. Use tags to group checks. Configure timeout and failure status."
    },
    {
      "id": 62,
      "question": "Explain the difference between IApplicationBuilder and IEndpointRouteBuilder.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IApplicationBuilder: Configures request pipeline (middleware). IEndpointRouteBuilder: Configures endpoints (routes). Use IApplicationBuilder for middleware, IEndpointRouteBuilder for mapping endpoints in endpoint routing."
    },
    {
      "id": 63,
      "question": "What are the different ways to handle configuration changes?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "IOptionsSnapshot for per-request updates. IOptionsMonitor for singleton services. IConfiguration.GetReloadToken() for change notifications. PhysicalFileProvider.Watch for file changes. Implement IOptionsChangeTokenSource for custom providers."
    },
    {
      "id": 64,
      "question": "How do you implement custom action results?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IActionResult or inherit from ActionResult. Override ExecuteResultAsync. Use for: custom formats, specialized responses, protocol handlers. Can be used with ActionResult<T> for type safety."
    },
    {
      "id": 65,
      "question": "Explain the purpose of the IHostedService interface.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IHostedService defines background tasks that start/stop with application. Methods: StartAsync, StopAsync. Used for: timed tasks, message processing, resource cleanup. Implement directly or use BackgroundService base class."
    },
    {
      "id": 66,
      "question": "What is the difference between AddMvcCore and AddMvc?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "AddMvcCore: Minimal MVC services (routing, controllers). AddMvc: Full MVC stack (views, tag helpers, data annotations, etc.). Use AddMvcCore for lightweight APIs, AddMvc for full web applications with UI."
    },
    {
      "id": 67,
      "question": "How do you implement custom route constraints?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IRouteConstraint, register with RouteOptions.ConstraintMap. Use for: custom validation in route templates, complex parameter matching. Can be used in attribute routing and conventional routing."
    },
    {
      "id": 68,
      "question": "Explain the difference between IOptions and IConfiguration.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IConfiguration: Raw configuration access, weakly typed. IOptions: Strongly-typed configuration with validation. Use IConfiguration for dynamic access, IOptions for structured, validated configuration in services."
    },
    {
      "id": 69,
      "question": "What are the different ways to register services?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "AddTransient, AddScoped, AddSingleton for lifetimes. AddSingleton<TService>(new Instance()). AddSingleton<TService, TImplementation>(). TryAdd* methods to avoid duplicates. Use extension methods for organization."
    },
    {
      "id": 70,
      "question": "How do you implement custom JSON serialization settings?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Configure JsonSerializerOptions in AddControllers().AddJsonOptions(). Settings: PropertyNamingPolicy, Converters, ReferenceHandler, DefaultIgnoreCondition. Use [JsonConverter] attribute for specific types."
    },
    {
      "id": 71,
      "question": "Explain the purpose of the IHttpContextAccessor interface.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IHttpContextAccessor provides access to HttpContext outside controllers. Register with services.AddHttpContextAccessor(). Use in services that need request context. Be careful with async and scoped dependencies."
    },
    {
      "id": 72,
      "question": "What is the difference between UseAuthentication and UseAuthorization?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "UseAuthentication: Middleware that authenticates user (who you are). UseAuthorization: Middleware that authorizes access (what you can do). Authentication must come before Authorization in pipeline. Both are needed for secure applications."
    },
    {
      "id": 73,
      "question": "How do you implement custom exception handlers?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Use ExceptionHandlerMiddleware with custom error handling path. Implement IExceptionHandler (.NET 7+). Use exception filters in MVC. Customize error responses based on exception type, environment, and client expectations."
    },
    {
      "id": 74,
      "question": "Explain the difference between AddDefaultIdentity and AddIdentity.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "AddDefaultIdentity: Pre-configured identity with UI, simpler setup. AddIdentity: Full control over identity configuration. Use AddDefaultIdentity for standard scenarios, AddIdentity for custom requirements."
    },
    {
      "id": 75,
      "question": "What are the different ways to configure Kestrel?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "In appsettings.json (Kestrel section). Programmatically with ConfigureKestrel(). UseListen(), UseHttps() methods. Configure: endpoints, certificates, limits, headers. Use for: SSL, HTTP/2, WebSockets, custom ports."
    },
    {
      "id": 76,
      "question": "How do you implement custom action method constraints?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IActionConstraint, use [ActionConstraint] attribute. Use for: versioning by header, content negotiation, custom routing logic. Constraints determine which action method is selected for a request."
    },
    {
      "id": 77,
      "question": "Explain the purpose of the IOptionsFactory<T>.",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "IOptionsFactory<T> creates options instances. Used internally by options services. Can be customized for: post-configuration, validation, dynamic options creation. Advanced scenario for complex options patterns."
    },
    {
      "id": 78,
      "question": "What is the difference between MapWhen and UseWhen?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "MapWhen: Branches pipeline based on predicate, creates separate pipeline. UseWhen: Conditionally adds middleware to main pipeline. Use MapWhen for completely separate pipelines, UseWhen for conditional middleware in main pipeline."
    },
    {
      "id": 79,
      "question": "How do you implement custom output formatters?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IOutputFormatter, register with AddMvcOptions.OutputFormatters. Use for: custom content types, specialized serialization. Can be selected based on content negotiation."
    },
    {
      "id": 80,
      "question": "Explain the difference between IHostBuilder and IWebHostBuilder.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IWebHostBuilder: For web applications (ASP.NET Core). IHostBuilder: Generic host for any type of application (workers, services). .NET 6+ uses WebApplicationBuilder which simplifies this distinction."
    },
    {
      "id": 81,
      "question": "What are the different ways to handle static files?",
      "category": "dotnet-core",
      "difficulty": "beginner",
      "answer": "UseStaticFiles() for wwwroot. UseFileServer() for directory browsing. UseDefaultFiles() for default files. UseDirectoryBrowser() for directory listing. Configure caching, compression, security headers for static files."
    },
    {
      "id": 82,
      "question": "How do you implement custom model validation providers?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IModelValidatorProvider, register with AddMvcOptions.ModelValidatorProviders. Use for: custom validation logic, integration with external validation services, complex validation scenarios."
    },
    {
      "id": 83,
      "question": "Explain the purpose of the IApplicationLifetime interface.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IApplicationLifetime (obsolete) / IHostApplicationLifetime: Manages application startup and shutdown. Events: ApplicationStarted, ApplicationStopping, ApplicationStopped. Use for: graceful shutdown, resource cleanup, health reporting."
    },
    {
      "id": 84,
      "question": "What is the difference between TryAdd and Add services?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Add: Always registers service, multiple registrations possible. TryAdd: Only registers if no implementation exists. TryAddEnumerable: Registers only if no same implementation exists. Use TryAdd* to avoid duplicate registrations."
    },
    {
      "id": 85,
      "question": "How do you implement custom parameter binders?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IModelBinderProvider, register with AddMvcOptions.ModelBinderProviders. Use for: complex parameter types, custom binding sources, specialized binding logic not covered by default binders."
    },
    {
      "id": 86,
      "question": "Explain the difference between IHostEnvironment and IWebHostEnvironment.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IHostEnvironment: Generic host environment (ContentRootPath, EnvironmentName). IWebHostEnvironment: Web-specific (WebRootPath). IWebHostEnvironment extends IHostEnvironment. Use IWebHostEnvironment in web applications."
    },
    {
      "id": 87,
      "question": "What are the different ways to configure logging?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "appsettings.json (Logging section). Programmatically with ConfigureLogging(). Use AddConsole, AddDebug, AddEventSource, etc. Configure levels, filters, providers. Use structured logging with message templates."
    },
    {
      "id": 88,
      "question": "How do you implement custom view locations?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Configure RazorViewEngineOptions.ViewLocationFormats. Implement IViewLocationExpander for dynamic view locations. Use for: multi-tenant applications, theme support, custom view hierarchies."
    },
    {
      "id": 89,
      "question": "Explain the purpose of the IOptionsChangeTokenSource<T>.",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "IOptionsChangeTokenSource<T> provides change tokens for options reloading. Used internally for configuration change detection. Can be implemented for custom configuration sources to support reload-on-change."
    },
    {
      "id": 90,
      "question": "What is the difference between AddControllers and AddRazorPages?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "AddControllers: For API controllers (JSON/XML responses). AddRazorPages: For Razor Pages (HTML responses). Use AddControllers for Web APIs, AddRazorPages for server-rendered HTML applications. Can use both in same application."
    },
    {
      "id": 91,
      "question": "How do you implement custom action invokers?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IActionInvokerProvider, register with AddMvcOptions. Use for: custom action execution, AOP, cross-cutting concerns. Advanced scenario for framework extensibility."
    },
    {
      "id": 92,
      "question": "Explain the difference between IMemoryCache and MemoryCache.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "IMemoryCache: Interface for dependency injection. MemoryCache: Concrete implementation. Always use IMemoryCache in application code for testability and flexibility. The DI container provides the implementation."
    },
    {
      "id": 93,
      "question": "What are the different ways to handle session state?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use distributed cache (IDistributedCache) for session storage. Configure with AddSession(), UseSession(). Use for: user preferences, shopping carts, multi-step forms. Consider scalability and performance implications."
    },
    {
      "id": 94,
      "question": "How do you implement custom authorization policies?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use AuthorizationPolicyBuilder to create policies. Add requirements with RequireClaim, RequireRole, RequireAssertion. Implement IAuthorizationRequirement and AuthorizationHandler<T>. Register with AddAuthorization()."
    },
    {
      "id": 95,
      "question": "Explain the purpose of the IHostBuilder.ConfigureServices method.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "ConfigureServices on IHostBuilder registers services in DI container. Called during host building. Can be called multiple times, services are additive. Use for service registration in generic host applications."
    },
    {
      "id": 96,
      "question": "What is the difference between UseRouting and UseEndpoints?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "UseRouting: Matches request to endpoint. UseEndpoints: Executes matched endpoint. Middleware between UseRouting and UseEndpoints can see which endpoint was selected. Both are needed for endpoint routing."
    },
    {
      "id": 97,
      "question": "How do you implement custom configuration sources?",
      "category": "dotnet-core",
      "difficulty": "advanced",
      "answer": "Implement IConfigurationSource and IConfigurationProvider. Add with ConfigurationBuilder.Add(source). Use for: database configuration, feature flags, remote configuration services. Support reloading if needed."
    },
    {
      "id": 98,
      "question": "Explain the difference between IApplicationBuilder.Use and IApplicationBuilder.Run.",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use: Adds middleware that can call next middleware in pipeline. Run: Adds terminal middleware that ends the pipeline. Use for middleware that processes request and may continue, Run for final response handlers."
    },
    {
      "id": 99,
      "question": "What are the different ways to handle content negotiation?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use Produces attribute to specify supported formats. Configure input/output formatters. Use Accept header for client-driven negotiation. Implement custom IOutputFormatter for specialized formats."
    },
    {
      "id": 100,
      "question": "How do you implement application lifetime events?",
      "category": "dotnet-core",
      "difficulty": "intermediate",
      "answer": "Use IHostApplicationLifetime for startup/shutdown events. Register with services. Use for: initialization, cleanup, health reporting. Handle ApplicationStarted, ApplicationStopping, ApplicationStopped events."
    }
  ]
}