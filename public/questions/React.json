{
  "data": [
    {
      "id": 1,
      "question": "What is the difference between state and props?",
      "category": "react",
      "difficulty": "beginner",
      "answer": "State is internal, mutable data managed within a component. Props are external, immutable data passed from parent to child. State triggers re-renders when changed, props cause re-renders when parent re-renders with new props."
    },
    {
      "id": 2,
      "question": "Explain React hooks (useState, useEffect, useContext).",
      "category": "react",
      "difficulty": "beginner",
      "answer": "useState: Manages component state. useEffect: Handles side effects (API calls, subscriptions). useContext: Accesses context values without prop drilling. Hooks must be called at top level and only in functional components."
    },
    {
      "id": 3,
      "question": "What is Virtual DOM and how does it work?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Virtual DOM is a lightweight copy of real DOM. When state changes, React creates new VDOM, compares with previous using diffing algorithm, then efficiently updates only changed parts in real DOM. Improves performance by minimizing direct DOM manipulation."
    },
    {
      "id": 4,
      "question": "How do you handle component lifecycle in functional components?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Using useEffect hook: useEffect(() => {}, []) = componentDidMount, useEffect(() => () => {}, []) = componentWillUnmount, useEffect(() => {}, [dependency]) = componentDidUpdate. useLayoutEffect for synchronous DOM updates."
    },
    {
      "id": 5,
      "question": "What are Higher-Order Components (HOCs)?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "HOCs are functions that take a component and return enhanced component. Used for code reuse, logic abstraction, and cross-cutting concerns. Pattern: const EnhancedComponent = HOC(BaseComponent);"
    },
    {
      "id": 6,
      "question": "Explain React context API and when to use it.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Context provides way to pass data through component tree without prop drilling. Create with React.createContext(), provide with Context.Provider, consume with useContext hook or Context.Consumer. Use for global data like themes, user auth, language."
    },
    {
      "id": 7,
      "question": "How do you optimize React application performance?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Use React.memo for component memoization, useCallback/useMemo for function/value memoization, code splitting with React.lazy, virtualization for large lists, optimize re-renders, bundle analysis, and proper dependency arrays in effects."
    },
    {
      "id": 8,
      "question": "What is JSX and how does it differ from HTML?",
      "category": "react",
      "difficulty": "beginner",
      "answer": "JSX is JavaScript syntax extension that looks like HTML. Differences: className vs class, htmlFor vs for, camelCase attributes (onClick), self-closing tags required, JavaScript expressions in {}, and it compiles to React.createElement calls."
    },
    {
      "id": 9,
      "question": "Explain React Router and navigation.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "React Router handles client-side routing. Components: BrowserRouter, Routes, Route, Link, useNavigate hook. Provides declarative routing, nested routes, route parameters, programmatic navigation, and code-splitting integration."
    },
    {
      "id": 10,
      "question": "How do you handle forms in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Controlled components: form data handled by React state via value/onChange. Uncontrolled components: form data handled by DOM using refs. Use form libraries like Formik or React Hook Form for complex forms with validation."
    },
    {
      "id": 11,
      "question": "What are React fragments and when to use them?",
      "category": "react",
      "difficulty": "beginner",
      "answer": "Fragments let you group elements without adding extra DOM nodes. Syntax: <React.Fragment> or <>. Use when you need to return multiple elements from component but don't want wrapper div. Improves semantic HTML and performance."
    },
    {
      "id": 12,
      "question": "Explain the useReducer hook and when to use it.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useReducer is alternative to useState for complex state logic. Takes reducer function and initial state. Returns current state and dispatch function. Use when state transitions are complex or when next state depends on previous state."
    },
    {
      "id": 13,
      "question": "What are custom hooks and how to create them?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Custom hooks extract component logic into reusable functions. Start with 'use' prefix, can call other hooks. Use for sharing stateful logic between components without repeating code or using HOCs/render props."
    },
    {
      "id": 14,
      "question": "Explain error boundaries in React.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Error boundaries catch JavaScript errors in child components and display fallback UI. Class components with static getDerivedStateFromError or componentDidCatch. Don't catch errors in event handlers, async code, or themselves."
    },
    {
      "id": 15,
      "question": "What are React portals and their use cases?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Portals render children into different DOM subtree. ReactDOM.createPortal(child, container). Use for modals, tooltips, popovers that need to break out of parent container constraints. Events still bubble through React tree. Use cases include modals that need different z-index context, breaking out of overflow:hidden containers."
    },
    {
      "id": 16,
      "question": "Explain the useRef hook and its use cases.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useRef returns mutable ref object that persists across re-renders. .current property holds value. Use for: accessing DOM elements, storing mutable values without causing re-renders, keeping previous state values."
    },
    {
      "id": 17,
      "question": "What are controlled vs uncontrolled components?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Controlled: Form data handled by React state, single source of truth. Uncontrolled: Form data handled by DOM, use refs to access values. Controlled preferred for validation and complex interactions, uncontrolled for simple forms."
    },
    {
      "id": 18,
      "question": "How do you handle events in React?",
      "category": "react",
      "difficulty": "beginner",
      "answer": "Events use camelCase (onClick), pass function as handler, not string. SyntheticEvent wraps native events for cross-browser compatibility. Prevent default with e.preventDefault(), not return false. Bind methods or use arrow functions."
    },
    {
      "id": 19,
      "question": "Explain React component composition patterns.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Composition over inheritance. Patterns: Containment (children prop), Specialization (specific components wrapping generic ones), Render props, Higher-Order Components. Creates more flexible and maintainable components. Composition is preferred over inheritance in React."
    },
    {
      "id": 20,
      "question": "What are React keys and why are they important?",
      "category": "react",
      "difficulty": "beginner",
      "answer": "Keys help React identify which items changed, were added, or removed. Should be unique and stable. Use item IDs, not array indices. Essential for correct rendering of dynamic lists and performance optimization."
    },
    {
      "id": 21,
      "question": "Explain the useMemo hook and optimization.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useMemo memoizes expensive calculations. Returns memoized value, recalculates only when dependencies change. Use for costly computations, object creation in renders. Don't overuse - has memory overhead."
    },
    {
      "id": 22,
      "question": "What is the useCallback hook and when to use it?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useCallback memoizes functions. Returns memoized callback, recreates only when dependencies change. Use when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary re-renders."
    },
    {
      "id": 23,
      "question": "How do you handle state management in large React applications?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Use Context API for app-wide state, Redux/Zustand for complex global state, React Query/SWR for server state, local state for component-specific data. Combine based on app needs and complexity."
    },
    {
      "id": 24,
      "question": "Explain React.memo and when to use it.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "React.memo is higher-order component that memoizes functional components. Prevents re-renders if props haven't changed. Use for expensive components with same props. Don't use for components that frequently get different props."
    },
    {
      "id": 25,
      "question": "What are render props in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Render props pattern: component receives function as prop that returns React elements. Enables code sharing and cross-cutting concerns. Alternative to HOCs. Use when you need flexibility in what gets rendered."
    },
    {
      "id": 26,
      "question": "How do you test React components?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Use Jest as test runner, React Testing Library for component testing. Test behavior, not implementation. Query elements, fire events, assert outcomes. Use jest.mock for mocking, MSW for API mocking."
    },
    {
      "id": 27,
      "question": "Explain code splitting in React.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Code splitting splits bundle into smaller chunks loaded on demand. Use React.lazy for component-level splitting, import() for route-level splitting. Reduces initial bundle size and improves load time."
    },
    {
      "id": 28,
      "question": "What are React suspense and concurrent features?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Suspense lets components wait for something before rendering. Concurrent features: startTransition for non-urgent updates, useDeferredValue for deferring re-renders, useTransition for pending states. Improves user experience."
    },
    {
      "id": 29,
      "question": "How do you handle forms with complex validation?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Use form libraries like React Hook Form (performance focused), Formik (declarative), or Final Form. Handle validation with schema validators (Yup, Zod). Manage form state, errors, submission, and dirty tracking."
    },
    {
      "id": 30,
      "question": "Explain the useImperativeHandle hook.",
      "category": "react",
      "difficulty": "advanced",
      "answer": "useImperativeHandle customizes instance value exposed when using ref. Used with forwardRef. Allows parent components to call methods on child component. Use sparingly - breaks component encapsulation."
    },
    {
      "id": 31,
      "question": "What are React server components?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Server components run on server, zero bundle size. Can access backend directly, improve performance. Client components run on client. Use .server.js/.client.js extensions. Part of React 18+ architecture."
    },
    {
      "id": 32,
      "question": "How do you optimize React application bundle size?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Code splitting, tree shaking, lazy loading, bundle analysis (Webpack Bundle Analyzer), compression, CDN for dependencies, removing unused code, using smaller alternative libraries."
    },
    {
      "id": 33,
      "question": "Explain React performance optimization techniques.",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Memoization (React.memo, useMemo, useCallback), virtualization for large lists, avoiding inline objects/functions, proper dependency arrays, code splitting, production builds, React DevTools profiling."
    },
    {
      "id": 34,
      "question": "What are React refs and forwardRef?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Refs access DOM nodes or React elements. forwardRef passes ref through component to child. Use for: focus management, text selection, media playback, triggering animations, integrating with third-party DOM libraries. Also used for prop forwarding patterns."
    },
    {
      "id": 35,
      "question": "How do you handle authentication in React apps?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Use Context for auth state, protected routes with wrapper components, store tokens securely (httpOnly cookies preferred over localStorage), handle token refresh, implement logout, use authentication providers (Auth0, Firebase)."
    },
    {
      "id": 36,
      "question": "Explain React state update batching.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "React batches multiple state updates into single re-render for performance. In React 17 and earlier, batching only in React event handlers. React 18+ batches all updates by default. Use flushSync for immediate updates when needed."
    },
    {
      "id": 37,
      "question": "What are React strict mode and its benefits?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "StrictMode activates additional checks and warnings. Identifies unsafe lifecycles, legacy API usage, unexpected side effects. Helps write better React code but only runs in development."
    },
    {
      "id": 38,
      "question": "How do you handle side effects in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Use useEffect hook for side effects. Return cleanup function. Specify dependency array. Use for: API calls, subscriptions, timers, manual DOM manipulations. Separate concerns with multiple effects."
    },
    {
      "id": 39,
      "question": "Explain React component design patterns.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Presentational vs Container components, Compound components, Provider pattern, Render props, HOCs, Custom hooks. Choose based on reusability, complexity, and team preferences."
    },
    {
      "id": 40,
      "question": "How do you handle global state in React?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Context API for simple global state, Redux for complex applications, Zustand for lightweight state, Recoil for derived state, MobX for observable patterns. Choose based on app size and complexity."
    },
    {
      "id": 41,
      "question": "What are React pure components?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "PureComponent implements shouldComponentUpdate with shallow prop and state comparison. Prevents re-renders if props/state haven't changed. Functional equivalent is React.memo with custom comparison function."
    },
    {
      "id": 42,
      "question": "How do you handle routing in React applications?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "React Router for SPAs, file-based routing with Next.js, route-based code splitting, nested routes, route parameters, programmatic navigation, protected routes, and lazy loading routes."
    },
    {
      "id": 43,
      "question": "Explain React context optimization techniques.",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Split contexts by domain, use multiple providers, memoize context values, use selectors for large state, consider state management libraries for frequent updates. Prevents unnecessary re-renders in context consumers. Addresses context limitations like unnecessary re-renders."
    },
    {
      "id": 44,
      "question": "What are React error boundaries best practices?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Place at strategic levels, use for graceful degradation, log errors to monitoring service, display user-friendly error messages, don't overuse - let some errors propagate for debugging."
    },
    {
      "id": 45,
      "question": "How do you handle API calls in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useEffect for data fetching, useState for loading/error states, abort controllers for cancellation, React Query/SWR for caching and synchronization, custom hooks for reuse, error boundaries for error handling."
    },
    {
      "id": 46,
      "question": "Explain React component testing strategies.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Test user behavior not implementation, use React Testing Library, mock external dependencies, test accessibility, use MSW for API mocking, test error states, test component integration, not isolated units."
    },
    {
      "id": 47,
      "question": "What are React best practices for props?",
      "category": "react",
      "difficulty": "beginner",
      "answer": "Use TypeScript/PropTypes, destructure props, avoid prop drilling (use context), default props, avoid mutating props, use meaningful prop names, keep props minimal and focused."
    },
    {
      "id": 48,
      "question": "How do you handle animations in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "CSS transitions/animations, React Spring/Framer Motion for complex animations, React Transition Group for mount/unmount animations, use key prop for list animations, prefer transform/opacity for performance."
    },
    {
      "id": 49,
      "question": "Explain React component patterns for reusability.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Compound components (shared implicit state), render props (flexible rendering), custom hooks (stateful logic), HOCs (cross-cutting concerns), provider pattern (dependency injection), component factories."
    },
    {
      "id": 50,
      "question": "What are React performance monitoring tools?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "React DevTools Profiler, why-did-you-render, React Strict Mode, browser performance tools, bundle analyzers, Lighthouse, Web Vitals monitoring, error tracking services."
    },
    {
      "id": 51,
      "question": "How do you handle file uploads in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "input type=file with onChange, FormData for multipart uploads, progress indicators, drag-and-drop interfaces, file validation, chunked uploads for large files, preview generation, error handling."
    },
    {
      "id": 52,
      "question": "Explain React component styling approaches.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "CSS Modules (scoped styles), Styled Components (CSS-in-JS), Tailwind CSS (utility-first), Sass/Less (preprocessors), CSS-in-JS libraries, CSS frameworks, inline styles for dynamic values."
    },
    {
      "id": 53,
      "question": "What are React server-side rendering benefits?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Faster initial load, SEO improvement, social media sharing previews, better performance on slow devices, progressive enhancement. Use Next.js, Remix, or custom SSR setup."
    },
    {
      "id": 54,
      "question": "How do you handle real-time updates in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "WebSockets (socket.io), Server-Sent Events, polling, GraphQL subscriptions, Firebase Realtime Database, optimistic updates, handling connection states, reconnection logic."
    },
    {
      "id": 55,
      "question": "Explain React component prop drilling solutions.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Context API, component composition, render props, higher-order components, state management libraries, custom hooks. Choose based on complexity and how many components need the data."
    },
    {
      "id": 56,
      "question": "What are React code organization best practices?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Feature-based folder structure, colocate related files, index files for clean imports, consistent naming, separate concerns, custom hooks for logic, TypeScript for type safety, absolute imports."
    },
    {
      "id": 57,
      "question": "How do you handle internationalization in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "react-i18next library, JSON translation files, language detection, pluralization, formatting (dates/numbers), RTL support, lazy loading translations, context for current language."
    },
    {
      "id": 58,
      "question": "Explain React component accessibility practices.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Semantic HTML, proper ARIA attributes, keyboard navigation, focus management, screen reader support, color contrast, form labels, error announcements, testing with accessibility tools."
    },
    {
      "id": 59,
      "question": "What are React state management anti-patterns?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Storing derived state, mutating state directly, overusing context, unnecessary global state, complex state objects, not using functional updates, improper effect dependencies."
    },
    {
      "id": 60,
      "question": "How do you implement search and filtering in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Controlled search input, debounced API calls, client-side filtering with useMemo, pagination, sorting, facet filters, URL state management, loading states, empty states."
    },
    {
      "id": 61,
      "question": "Explain React component testing with Jest and RTL.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Jest for test runner, React Testing Library for queries and assertions, user-event for interactions, MSW for API mocking, test accessibility, avoid testing implementation details."
    },
    {
      "id": 62,
      "question": "What are React optimization patterns for lists?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Virtualization (react-window), key prop optimization, memoization, pagination, infinite scrolling, lazy loading, avoiding inline functions in map, stable sort functions."
    },
    {
      "id": 63,
      "question": "How do you handle errors in React applications?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Error boundaries for component errors, try/catch for event handlers, proper error states in UI, error logging services, user-friendly error messages, fallback UIs, monitoring and alerting."
    },
    {
      "id": 64,
      "question": "Explain React component design system creation.",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Atomic design methodology, consistent props API, composition patterns, theme provider, variant system, documentation (Storybook), accessibility compliance, testing strategy."
    },
    {
      "id": 65,
      "question": "What are React state update performance considerations?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Batch updates, avoid deep object nesting, use Immer for complex updates, functional updates for sequential state, proper dependency arrays, avoid unnecessary state, use refs for mutable values."
    },
    {
      "id": 66,
      "question": "How do you implement drag and drop in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "react-dnd or react-beautiful-dnd libraries, HTML5 drag and drop API, touch device support, accessibility considerations, visual feedback, data transfer, drop zones, reordering logic."
    },
    {
      "id": 67,
      "question": "Explain React component lazy loading patterns.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "React.lazy for components, Suspense for loading states, route-based code splitting, prefetching, error boundaries for failures, named chunks, dynamic imports with webpack."
    },
    {
      "id": 68,
      "question": "What are React hooks rules and why they exist?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Only call hooks at top level, only call hooks from React functions. Rules ensure hooks are called in same order each render, which is how React associates state with components. ESLint plugin enforces rules."
    },
    {
      "id": 69,
      "question": "How do you handle pagination in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Offset-based pagination, cursor-based pagination, infinite scroll, page number navigation, URL state management, loading states, cache management, prefetching next pages."
    },
    {
      "id": 70,
      "question": "Explain React component prop types and validation.",
      "category": "react",
      "difficulty": "beginner",
      "answer": "PropTypes for runtime validation, TypeScript for compile-time types, default props, required props, custom validators, shape validation for objects, array validators."
    },
    {
      "id": 71,
      "question": "How do you implement dark mode in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Context for theme state, CSS variables for theming, useMediaQuery for system preference, localStorage for persistence, toggle component, apply classes to body/elements, smooth transitions."
    },
    {
      "id": 72,
      "question": "Explain React component patterns for reusability.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Compound components (shared implicit state), render props (flexible rendering), custom hooks (stateful logic), HOCs (cross-cutting concerns), provider pattern (dependency injection), component factories."
    },
    {
      "id": 73,
      "question": "How do you handle file downloads in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Blob URLs for client-generated files, anchor tags with download attribute, server-side file generation with progress, error handling, authentication for protected files, multiple file downloads."
    },
    {
      "id": 74,
      "question": "Explain React component prop design patterns.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Variant props (primary, secondary), size props, disabled states, icon props, children for content, render props for customization, compound props for related values, spread props for HTML attributes."
    },
    {
      "id": 75,
      "question": "What are React performance profiling techniques?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "React DevTools Profiler, performance measurements, why-did-you-render for unnecessary re-renders, bundle analysis, Lighthouse audits, user timing API, production profiling."
    },
    {
      "id": 76,
      "question": "How do you implement feature flags in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Context for feature state, conditional rendering based on flags, gradual rollouts, A/B testing integration, remote configuration, user segmentation, fallback for failed flag fetches."
    },
    {
      "id": 77,
      "question": "Explain React component tree optimization.",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Flatten component hierarchy, avoid deep nesting, use composition over wrapper components, colocate state, use context selectively, memoize expensive branches, code split at route level."
    },
    {
      "id": 78,
      "question": "What are React hook custom hook patterns?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Stateful logic hooks, event handler hooks, API call hooks, form handling hooks, animation hooks, subscription hooks, utility hooks. Return values and functions, not JSX."
    },
    {
      "id": 79,
      "question": "How do you handle scroll interactions in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useEffect with scroll event listeners, intersection observer for element visibility, scroll to element functionality, virtualized lists for performance, scroll restoration, custom scroll bars."
    },
    {
      "id": 80,
      "question": "What are React state persistence strategies?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "localStorage/sessionStorage, URL state, backend persistence, offline support with service workers, conflict resolution for concurrent edits, state serialization, migration strategies."
    },
    {
      "id": 81,
      "question": "How do you implement keyboard shortcuts in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useEffect with keydown events, custom hook for shortcuts, prevent default behavior, accessibility considerations, conflict resolution, user customization, visual feedback for active shortcuts."
    },
    {
      "id": 82,
      "question": "Explain React component data fetching patterns.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useEffect for mount-time fetching, SWR/React Query for caching, loading/error states, pagination, refetching on interval, optimistic updates, background sync, error boundaries for failures."
    },
    {
      "id": 83,
      "question": "What are React application architecture patterns?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Feature-based organization, domain-driven design, clean architecture, micro-frontends, monorepo structure, design system integration, testing strategy, deployment pipeline, monitoring setup."
    },
    {
      "id": 84,
      "question": "How do you handle forms with React Hook Form?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "useForm hook, register fields, handleSubmit for validation, watch for field changes, setValue for programmatic updates, formState for errors/touched/dirty states, minimal re-renders, good performance."
    },
    {
      "id": 85,
      "question": "Explain React state update queues and timing.",
      "category": "react",
      "difficulty": "advanced",
      "answer": "State updates are asynchronous and batched. Updates are enqueued and processed in order. Functional updates ensure correct previous state. Effects run after render. Use flushSync for synchronous updates when necessary."
    },
    {
      "id": 86,
      "question": "How do you implement undo/redo in React?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Store state history array, current index pointer, actions to move through history, immutability for state snapshots, limits on history size, merging similar actions, keyboard shortcuts."
    },
    {
      "id": 87,
      "question": "Explain React component testing best practices.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Test behavior not implementation, use accessible queries, test error states, mock external dependencies, test user flows, avoid testing implementation details, use realistic data."
    },
    {
      "id": 88,
      "question": "What are React state normalization techniques?",
      "category": "react",
      "difficulty": "advanced",
      "answer": "Store entities by id in objects, keep arrays of IDs, use selectors for denormalization, avoid nested updates, use libraries like Normalizr, maintain referential integrity."
    },
    {
      "id": 89,
      "question": "How do you handle responsive design in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "CSS media queries, useMediaQuery hook, container queries, responsive props in component libraries, mobile-first approach, touch-friendly interfaces, performance on mobile devices."
    },
    {
      "id": 90,
      "question": "Explain React component error recovery patterns.",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Error boundaries with retry mechanisms, fallback UIs, error reporting, user feedback, graceful degradation, circuit breaker patterns for API failures."
    },
    {
      "id": 91,
      "question": "What are React hook dependencies best practices?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "Include all values from component scope that change over time, use eslint-plugin-react-hooks, avoid objects/functions in dependencies, use useCallback/useMemo for stable references."
    },
    {
      "id": 92,
      "question": "How do you implement real-time charts in React?",
      "category": "react",
      "difficulty": "intermediate",
      "answer": "WebSocket connections, chart libraries (Chart.js, Recharts), data streaming, performance optimization for frequent updates, debouncing renders, smooth animations, responsive sizing."
    },
    {
      "id": 1,
      "question": "Which library is most commonly used for lightweight form validation in modern React apps?",
      "options": ["Formik", "React Hook Form", "Redux Form", "MobX Form"],
      "answer": "React Hook Form"
    },
    {
      "id": 2,
      "question": "Which library is commonly paired with Formik for schema-based validation?",
      "options": ["Zod", "Joi", "Yup", "Validator.js"],
      "answer": "Yup"
    },
    {
      "id": 3,
      "question": "Which validation type is used when you check input values while the user is typing?",
      "options": ["Submit-time validation", "Async validation", "Real-time validation", "Lazy validation"],
      "answer": "Real-time validation"
    },
    {
      "id": 4,
      "question": "Which built-in HTML attribute is used for required fields in React forms?",
      "options": ["mandatory", "need", "required", "must"],
      "answer": "required"
    },
    {
      "id": 5,
      "question": "Which schema validation library is faster and very TypeScript friendly?",
      "options": ["Yup", "Zod", "Joi", "Validator.js"],
      "answer": "Zod"
    },
    {
      "id": 6,
      "question": "What type of component keeps form state inside React using useState?",
      "options": ["Uncontrolled component", "Controlled component", "Pure component", "Lazy component"],
      "answer": "Controlled component"
    },
    {
      "id": 7,
      "question": "Which attribute is used to validate email format in HTML?",
      "options": ["type='text'", "type='mail'", "type='email'", "validate='email'"],
      "answer": "type='email'"
    },
    {
      "id": 8,
      "question": "Which event is commonly used to trigger validation when the user leaves a field?",
      "options": ["onChange", "onClick", "onBlur", "onFocus"],
      "answer": "onBlur"
    },
    {
      "id": 9,
      "question": "Which React Hook Form function is used to submit the form?",
      "options": ["handleSubmit", "submitForm", "validateForm", "runSubmit"],
      "answer": "handleSubmit"
    },
    {
      "id": 10,
      "question": "Which library provides string validation like email, URL, and credit card checks?",
      "options": ["Formik", "React Hook Form", "Validator.js", "Joi"],
      "answer": "Validator.js"
    }

  ]
}