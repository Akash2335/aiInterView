{
  "data": [
    {
      "id": 1,
      "question": "Can you use await without async?",
      "category": "async-await",
      "difficulty": "beginner",
      "answer": "No, you cannot use the await keyword without marking the method with the async modifier. The async keyword enables the await functionality and tells the compiler to transform the method into a state machine that can handle asynchronous operations."
    },
    {
      "id": 2,
      "question": "What happens if you forget to await an async method?",
      "category": "async-await",
      "difficulty": "beginner",
      "answer": "If you forget to await an async method, the method will return a Task immediately without waiting for the asynchronous operation to complete. This can lead to unexpected behavior, exceptions going unobserved, and the program continuing execution before the async operation finishes."
    },
    {
      "id": 3,
      "question": "How does async/await improve application performance?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Async/await improves performance by enabling non-blocking I/O operations. Instead of blocking threads while waiting for I/O (like database calls, file operations, or web requests), threads are released back to the thread pool to handle other work, improving scalability and resource utilization."
    },
    {
      "id": 4,
      "question": "What is the difference between Task and Task<T>?",
      "category": "async-await",
      "difficulty": "beginner",
      "answer": "Task represents an asynchronous operation that doesn't return a value (similar to void), while Task<T> represents an asynchronous operation that returns a value of type T. Task is used for fire-and-forget operations, while Task<T> is used when you need to retrieve a result from the async operation."
    },
    {
      "id": 5,
      "question": "How do you create and start a Task?",
      "category": "async-await",
      "difficulty": "beginner",
      "answer": "You can create and start a Task using Task.Run(), Task.Factory.StartNew(), or by calling an async method. For CPU-bound work: Task.Run(() => SomeMethod()). For I/O-bound work: directly call async methods. Tasks created with 'new Task()' need to be explicitly started with .Start()."
    },
    {
      "id": 6,
      "question": "What are the different ways to wait for a Task to complete?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "1. await task (non-blocking, preferred), 2. task.Wait() (blocking, can cause deadlocks), 3. task.Result (blocking, can cause deadlocks), 4. Task.WaitAll() (blocks until all tasks complete), 5. Task.WhenAll() (non-blocking, returns a task), 6. task.GetAwaiter().GetResult() (blocks, similar to .Result)"
    },
    {
      "id": 7,
      "question": "When should you use Task.Run vs Task.Factory.StartNew?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use Task.Run for common CPU-bound scenarios as it's simpler and uses sensible defaults. Use Task.Factory.StartNew when you need more control over task creation options, custom task schedulers, or specific TaskCreationOptions. Task.Run is essentially a simplified wrapper around Task.Factory.StartNew with default parameters."
    },
    {
      "id": 8,
      "question": "What are the performance implications of each?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "Task.Run has slightly better performance for common scenarios due to optimized defaults. Task.Factory.StartNew has more overhead but provides flexibility. Both use the thread pool, so excessive use can lead to thread pool starvation. For I/O-bound work, neither should be used - call async methods directly instead."
    },
    {
      "id": 9,
      "question": "How do they handle task scheduling differently?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "Task.Run always uses the default task scheduler (ThreadPool). Task.Factory.StartNew allows specifying a custom task scheduler via the TaskScheduler parameter. This enables scenarios like using a dedicated scheduler for UI thread work, limited concurrency schedulers, or custom scheduling logic."
    },
    {
      "id": 10,
      "question": "What is the state machine generated by the compiler?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "The compiler transforms async methods into state machine classes that implement IAsyncStateMachine. This state machine handles pausing and resuming execution at await points, preserving local variables across suspensions, and managing the method's execution flow without blocking threads."
    },
    {
      "id": 11,
      "question": "How does exception handling work in async methods?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Exceptions in async methods are captured and stored in the returned Task. When you await the task, exceptions are re-thrown. Use try/catch blocks around await expressions. For async void methods, exceptions are raised on the SynchronizationContext and can crash the application if unhandled."
    },
    {
      "id": 12,
      "question": "What role does the SynchronizationContext play?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "SynchronizationContext represents execution context (like UI thread or ASP.NET request context). By default, await captures the current context and marshals continuations back to it. This ensures UI updates happen on the UI thread and ASP.NET operations preserve HttpContext. ConfigureAwait(false) ignores the context."
    },
    {
      "id": 13,
      "question": "When should you use ConfigureAwait(false)?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use ConfigureAwait(false) in library code to avoid capturing and marshaling back to the original context. This prevents deadlocks and improves performance. Don't use it in UI code where you need to update UI elements, or in ASP.NET Core where you need HttpContext."
    },
    {
      "id": 14,
      "question": "What are the deadlock risks with ConfigureAwait(true)?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "Deadlocks occur when code blocks on a task (using .Result, .Wait(), or .GetAwaiter().GetResult()) while holding a synchronization context. The async method tries to marshal back to the blocked context, creating a circular dependency. This commonly happens in UI applications or ASP.NET with improper async usage."
    },
    {
      "id": 15,
      "question": "How does this affect UI applications vs library code?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "In UI applications, use default ConfigureAwait(true) to ensure UI updates happen on the UI thread. In library code, use ConfigureAwait(false) to avoid deadlocks and improve performance. Library code shouldn't assume anything about its execution context, while UI code depends on specific context behavior."
    },
    {
      "id": 16,
      "question": "What happens to exceptions thrown in async void methods?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Exceptions in async void methods are raised on the SynchronizationContext and can't be caught with normal try/catch. In UI apps, they may crash the application. In ASP.NET, they can terminate the request. Always use async Task instead of async void, except for event handlers where async void is required."
    },
    {
      "id": 17,
      "question": "How do you catch multiple exceptions from multiple tasks?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use Task.WhenAll() and catch AggregateException, then examine its InnerExceptions property. Example: try { await Task.WhenAll(tasks); } catch (AggregateException ex) { foreach (var inner in ex.InnerExceptions) { // Handle each exception } }"
    },
    {
      "id": 18,
      "question": "What is AggregateException?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "AggregateException is a special exception type that contains multiple exceptions. It's thrown by methods like Task.Wait(), Task.Result, and Task.WhenAll() when multiple tasks fail. Use the InnerExceptions property to access all contained exceptions."
    },
    {
      "id": 19,
      "question": "When is async void appropriate?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "async void is only appropriate for event handlers (like button clicks in UI apps) where the method signature is constrained to return void. In all other cases, use async Task. Event handlers are the only scenario where the fire-and-forget nature of async void is acceptable."
    },
    {
      "id": 20,
      "question": "Why should you avoid async void in most cases?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "async void should be avoided because: 1) Exceptions can't be caught and may crash the app, 2) You can't await completion, 3) It's difficult to test, 4) It breaks the composition model, 5) It can cause resource leaks if not properly handled."
    },
    {
      "id": 21,
      "question": "How does exception handling differ between them?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "async Task: Exceptions are captured in the Task and thrown when awaited. async void: Exceptions are raised directly on the SynchronizationContext, potentially crashing the application. async Task allows proper error handling and propagation, while async void makes exceptions unobservable to the caller."
    },
    {
      "id": 22,
      "question": "What is CancellationToken and how is it used?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "CancellationToken is a struct that propagates cancellation notifications. Pass it to async methods to enable cooperative cancellation. Check token.IsCancellationRequested periodically or call token.ThrowIfCancellationRequested() to cancel the operation gracefully."
    },
    {
      "id": 23,
      "question": "How do you create a CancellationTokenSource?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Create a CancellationTokenSource instance, then get the token from its Token property. Example: var cts = new CancellationTokenSource(); CancellationToken token = cts.Token; Call cts.Cancel() to trigger cancellation. Use cts.CancelAfter(TimeSpan) for automatic timeout cancellation."
    },
    {
      "id": 24,
      "question": "What is the proper way to check for cancellation in async methods?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "1) Periodically check token.IsCancellationRequested and break if true, 2) Call token.ThrowIfCancellationRequested() to immediately throw OperationCanceledException, 3) Pass the token to other async methods that support cancellation, 4) Register cancellation callbacks with token.Register()."
    },
    {
      "id": 25,
      "question": "Why does Task.Wait() cause deadlocks?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Task.Wait() causes deadlocks when called on a task that needs to marshal back to a synchronization context that's currently blocked. The async method can't complete because it's waiting for the context, but the context is blocked waiting for the task - creating a circular dependency."
    },
    {
      "id": 26,
      "question": "When is it appropriate to use Task.Wait()?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Task.Wait() is only appropriate in synchronous contexts where you can't use async/await, like in Main method before C# 7.1, or in legacy code that can't be made async. Even then, prefer .GetAwaiter().GetResult() as it provides better exception propagation. Avoid in UI or ASP.NET contexts."
    },
    {
      "id": 27,
      "question": "What is the performance difference between blocking and awaiting?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "Blocking (Wait(), Result) consumes a thread while waiting, potentially causing thread pool starvation. Awaiting releases the thread back to the thread pool during waits, enabling better scalability. For I/O operations, await is vastly more efficient. For very short operations, the overhead of async may outweigh benefits."
    },
    {
      "id": 28,
      "question": "What is the difference between Task.WhenAll and Task.WhenAny?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Task.WhenAll waits for all tasks to complete and returns when all are done. Task.WhenAny waits for any task to complete and returns the first finished task. Use WhenAll for parallel execution where you need all results. Use WhenAny for scenarios like timeouts, race conditions, or processing tasks as they complete."
    },
    {
      "id": 29,
      "question": "How do you handle results from multiple concurrent tasks?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use Task.WhenAll() to wait for all tasks, then access their results. Example: var tasks = items.Select(ProcessAsync); var results = await Task.WhenAll(tasks);. Results are returned in the same order as the input tasks. Handle exceptions with try/catch around WhenAll."
    },
    {
      "id": 30,
      "question": "What are the performance benefits of concurrent execution?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Concurrent execution can significantly reduce total execution time for I/O-bound operations by overlapping waits. Instead of waiting sequentially, multiple operations proceed simultaneously. For CPU-bound work, it utilizes multiple cores. However, excessive concurrency can cause resource contention and thread pool starvation."
    },
    {
      "id": 31,
      "question": "What are the performance benefits of ValueTask over Task?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "ValueTask avoids heap allocations when operations complete synchronously, reducing GC pressure. It's a value type that can represent either a synchronous result or a task. For hot paths with frequent synchronous completion, ValueTask provides better performance. For usually-async operations, Task is sufficient."
    },
    {
      "id": 32,
      "question": "When is ValueTask not appropriate?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "ValueTask is not appropriate when: 1) The result may be awaited multiple times, 2) Using certain patterns like async method builders, 3) The operation is usually asynchronous, 4) You need to store the task for later use. ValueTask should generally be awaited immediately and only once."
    },
    {
      "id": 33,
      "question": "How does ValueTask handle synchronous completion?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "When a ValueTask completes synchronously, it stores the result directly in the value type without allocating a Task on the heap. The awaiter checks if the operation completed synchronously and returns the result immediately without any async state machine overhead."
    },
    {
      "id": 34,
      "question": "What is the return type of an async method that returns int?",
      "category": "async-await",
      "difficulty": "beginner",
      "answer": "An async method that returns int should have the return type Task<int>. The compiler automatically wraps the int return value in a Task<int>. Example: async Task<int> GetNumberAsync() { return 42; }"
    },
    {
      "id": 35,
      "question": "How do you handle multiple return types in async methods?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use a wrapper type like a custom class, tuple, or discriminated union. Example: async Task<(bool Success, string Data)> GetDataAsync(). For complex scenarios, create a result class with properties for different return cases. Avoid using object or dynamic as it loses type safety."
    },
    {
      "id": 36,
      "question": "What is the difference between Task and Task<T> return types?",
      "category": "async-await",
      "difficulty": "beginner",
      "answer": "Task represents an asynchronous operation with no return value (like void). Task<T> represents an asynchronous operation that returns a value of type T. Use Task for fire-and-forget operations, and Task<T> when you need to retrieve a result from the async operation."
    },
    {
      "id": 37,
      "question": "How should you handle CPU-bound work asynchronously?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use Task.Run() to offload CPU-bound work to the thread pool. Example: var result = await Task.Run(() => ExpensiveCalculation()). This prevents blocking the calling thread (especially important for UI threads). Don't use async/await directly for CPU work without Task.Run."
    },
    {
      "id": 38,
      "question": "What are the best practices for I/O-bound async operations?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "1) Use async/await directly without Task.Run, 2) Use ConfigureAwait(false) in library code, 3) Prefer async methods provided by frameworks, 4) Use cancellation tokens for long operations, 5) Handle exceptions properly, 6) Use IAsyncDisposable for resource cleanup, 7) Avoid blocking calls."
    },
    {
      "id": 39,
      "question": "How does the thread pool handle each type?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "For I/O-bound work: Thread pool threads are used briefly to initiate I/O, then released during the wait. I/O completion ports handle the completion. For CPU-bound work with Task.Run: Thread pool threads are occupied for the duration of the computation. The thread pool dynamically grows to handle load but can exhaust resources."
    },
    {
      "id": 40,
      "question": "What common patterns cause async deadlocks?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "1) Calling .Result or .Wait() on a task in UI context, 2) Using Task.Run().Result inside async methods, 3) Blocking on async code in ASP.NET, 4) Nested Task.Run calls with blocking, 5) Improper use of synchronization primitives like lock with async code."
    },
    {
      "id": 41,
      "question": "How does SynchronizationContext contribute to deadlocks?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "SynchronizationContext creates a single-threaded context (like UI thread) that can only execute one piece of code at a time. When code blocks waiting for async work that needs to return to the same context, neither can proceed - the context is blocked waiting, and the async work can't marshal back."
    },
    {
      "id": 42,
      "question": "What are the best practices to avoid deadlocks?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "1) Use async/await all the way, 2) Use ConfigureAwait(false) in library code, 3) Never block on async code (.Result, .Wait()), 4) Use SemaphoreSlim.WaitAsync() instead of lock, 5) Use async-compatible synchronization primitives, 6) In UI apps, don't block the UI thread."
    },
    {
      "id": 43,
      "question": "When would you use TaskCompletionSource?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "Use TaskCompletionSource to: 1) Wrap callback-based APIs into Task-based APIs, 2) Create tasks that complete based on external events, 3) Implement async wrappers for synchronous code, 4) Create manually controlled tasks for testing, 5) Bridge between different async patterns."
    },
    {
      "id": 44,
      "question": "How do you create and complete a TaskCompletionSource?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "Create: var tcs = new TaskCompletionSource<T>();. Complete with: tcs.SetResult(value) for success, tcs.SetException(exception) for failure, tcs.SetCanceled() for cancellation. Return tcs.Task to callers. The task completes when one of the Set methods is called."
    },
    {
      "id": 45,
      "question": "What are common use cases for TaskCompletionSource?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "1) Wrapping event-based APIs (like socket operations), 2) Implementing async methods over Begin/End patterns, 3) Creating tasks that complete on UI events, 4) Building custom async primitives, 5) Testing async code with controlled completion, 6) Implementing async queues or producers."
    },
    {
      "id": 46,
      "question": "What is the best way to add timeout to any async method?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use Task.WhenAny with the original task and Task.Delay: var completedTask = await Task.WhenAny(originalTask, Task.Delay(timeout)); if (completedTask != originalTask) throw new TimeoutException(); else return await originalTask;. Combine with CancellationTokenSource for proper cancellation."
    },
    {
      "id": 47,
      "question": "How do you cancel the operation when timeout occurs?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use CancellationTokenSource with CancelAfter(): var cts = new CancellationTokenSource(); cts.CancelAfter(timeout); then pass cts.Token to the async method. The method should periodically check the token and throw OperationCanceledException when cancelled. This ensures proper resource cleanup."
    },
    {
      "id": 48,
      "question": "What are the alternatives to Task.WhenAny for timeouts?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "1) CancellationTokenSource.CancelAfter(), 2) Polly library with TimeoutPolicy, 3) Custom timeout wrappers, 4) Using timers with TaskCompletionSource, 5) For HTTP calls, HttpClient.Timeout property. Task.WhenAny is the most straightforward and commonly used approach."
    },
    {
      "id": 49,
      "question": "When should you use Parallel.ForEach vs async/await?",
      "category": "async-await",
      "difficulty": "intermediate",
      "answer": "Use Parallel.ForEach for CPU-bound work that can be parallelized across multiple cores. Use async/await for I/O-bound work where threads can be released during waits. They can be combined: use Parallel inside Task.Run for CPU work, but be careful about thread pool exhaustion."
    },
    {
      "id": 50,
      "question": "Can async and parallel programming be combined?",
      "category": "async-await",
      "difficulty": "advanced",
      "answer": "Yes, but carefully. Use Task.Run with Parallel.ForEach for CPU-bound work inside async methods. Use SemaphoreSlim to limit concurrency. Use async-compatible collections like Channel for producer-consumer patterns. Be mindful of thread pool starvation and use appropriate degrees of parallelism."
    }
  ]
}